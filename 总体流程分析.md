# 总体流程

## 主方法
workerman的入口在Worker.php中的runAll方法中
该方法中包含以下事件

1. 检查当前运行环境(checkSapiEnv)
2. 初始化worker类成员变量(init)
3. 解析命令输入(parseCommand)
4. 守护进程化(daemonize)
5. 初始化子进程实体(initWorkers)
6. 信号安装(installSignal)
7. UI展示(displayUI)
8. fork子进程(forkWorkers)
9. 重定向输入输出(resetStd)
10. 监控进程状态(monitorWorkers)

## checkSapiEnv

此方法中判断当前环境是否为cli(command-line interface),如果不是在cli环境中需要终止程序的运行

## init

1. 设置pidFile(主进程ID文件)
2. 设置logFile(日志文件),不存在就创建
3. 初始化全局统计时间,$_globalStatistics
4. 设置全部统计文件statisticsFile
5. 设置进程标题
6. 初始化所有worker的id信息,此处主要是设置id对pid的关联关系
7. 初始化定时器

## 命令行解析

解析启动命令确定响应事件

1. 错误显示提示,如果用户输入命令错误提示正确使用方法

2. 确认当前的服务是否已经开启,start和restart不依赖服务是否启动,但是其他的命令都是需要服务启动才生效

   ```php
   $master_pid      = is_file(self::$pidFile) ? file_get_contents(self::$pidFile) : 0;

   $master_is_alive = $master_pid && @posix_kill($master_pid, 0) && posix_getpid() != $master_pid;
   ```

   对主进程是否存活进行判断

   1. 如果主进程启动完成过,那么pidFile会存入主进程pid但不能证明主进程目前还存活
   2. posix_kill确认主进程存活但是posix_kill并不算靠谱,因为linux系统会重复使用进程id
   3. posix_getpid() != $master_pid因以上的原因如果当前的进程id为文件中记录id那么主进程必然不存活

##守护进程化
当前就是在处理守护进程,此处说明一下守护进程的实现

```php
protected static function daemonize()
{
    if (!self::$daemonize) {
        return;
    }
    //将默认权限掩码修改为0,意味着即将要创建的文件的权限都是777
    umask(0);
    // 子进程
    $pid = pcntl_fork();
    // 子进程创建失败
    if (-1 === $pid) {
        throw new Exception('fork fail');
    } elseif ($pid > 0) {  //说明当前进程是父进程,只有在父进程中fork才会返回pid
        // 关闭父进程，让子进程成为孤儿进程被init进程收养
        exit(0);
    }
    // 将子进程作为进程组的leader,开启一个新的会话,脱离之前的会话和进程组。即使用户logout也不会终止
    if (-1 === posix_setsid()) {
        throw new Exception("setsid fail");
    }
    // Fork again avoid SVR4 system regain the control of terminal.
    // 避免svr4系统重新获取控制终端
    $pid = pcntl_fork();
    if (-1 === $pid) {
        throw new Exception("fork fail");
    } elseif (0 !== $pid) {
        // 如果不是孙子进程，直接干掉。让孙子进程成为孤儿进程被init进程（1号进程收养）
        exit(0);
    }
}
```
> 注释来源https://segmentfault.com/a/1190000007420468

补充说明:

1. umasklinux默认情况会设置文件掩码也就是说会控制文件的创建权限(-rwxrwxrwx),如果不将umask设置为0,用户创建文件后，可能获得的也不是想要的权限，因为掩码会自动的剔除对应的权限

   假设当前掩码是0022,那么默认文件就只有755权限

2. 默认情况下当退出了进程终端后，会话首进程会发送SIGHUP信号给所有的前台和后台进程,而进程默认接受到该信号的处理方案是终止进程

参考资料:

如果通过以上的注释仍不能理解推荐看,UNIX环境高级编程     第8章　进程控制  第9章  进程关系 第10章 信号 第13章　守护进程(本章有使用线程实现对本例理解用处不太)

##
